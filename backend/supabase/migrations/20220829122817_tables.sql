CREATE TABLE "public"."adoptions" (
	"user_id" uuid NOT NULL,
	"tree_id" integer NOT NULL,
	"created_at" timestamp with time zone NOT NULL DEFAULT CURRENT_TIMESTAMP
);

ALTER TABLE "public"."adoptions" ENABLE ROW LEVEL SECURITY;

CREATE TABLE "public"."districts" (
	"id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
	"name" text NOT NULL,
	"geom" geometry NOT NULL
);

CREATE TABLE "public"."profiles" (
	"id" uuid NOT NULL,
	"username" text
);

ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;

CREATE TABLE "public"."trees" (
	"id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
	"type" text NOT NULL,
	"geom" geometry NOT NULL,
	"age" integer,
	"height" double precision
);

ALTER TABLE "public"."trees" ENABLE ROW LEVEL SECURITY;

CREATE TABLE "public"."waterings" (
	"id" integer GENERATED BY DEFAULT AS IDENTITY NOT NULL,
	"amount" double precision NOT NULL,
	"tree_id" integer NOT NULL,
	"user_id" uuid NOT NULL
);

ALTER TABLE "public"."waterings" ENABLE ROW LEVEL SECURITY;

CREATE UNIQUE INDEX adoptions_pkey ON public.adoptions USING btree (user_id, tree_id);

CREATE UNIQUE INDEX districts_pkey ON public.districts USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX trees_pkey ON public.trees USING btree (id);

CREATE UNIQUE INDEX waterings_pkey ON public.waterings USING btree (id);

ALTER TABLE "public"."adoptions"
	ADD CONSTRAINT "adoptions_pkey" PRIMARY KEY USING INDEX "adoptions_pkey";

ALTER TABLE "public"."districts"
	ADD CONSTRAINT "districts_pkey" PRIMARY KEY USING INDEX "districts_pkey";

ALTER TABLE "public"."profiles"
	ADD CONSTRAINT "profiles_pkey" PRIMARY KEY USING INDEX "profiles_pkey";

ALTER TABLE "public"."trees"
	ADD CONSTRAINT "trees_pkey" PRIMARY KEY USING INDEX "trees_pkey";

ALTER TABLE "public"."waterings"
	ADD CONSTRAINT "waterings_pkey" PRIMARY KEY USING INDEX "waterings_pkey";

ALTER TABLE "public"."adoptions"
	ADD CONSTRAINT "adoptions_tree_id_fkey" FOREIGN KEY (tree_id) REFERENCES trees (id) NOT valid;

ALTER TABLE "public"."adoptions" validate CONSTRAINT "adoptions_tree_id_fkey";

ALTER TABLE "public"."adoptions"
	ADD CONSTRAINT "adoptions_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles (id) NOT valid;

ALTER TABLE "public"."adoptions" validate CONSTRAINT "adoptions_user_id_fkey";

ALTER TABLE "public"."profiles"
	ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users (id) NOT valid;

ALTER TABLE "public"."profiles" validate CONSTRAINT "profiles_id_fkey";

ALTER TABLE "public"."waterings"
	ADD CONSTRAINT "waterings_tree_id_fkey" FOREIGN KEY (tree_id) REFERENCES trees (id) NOT valid;

ALTER TABLE "public"."waterings" validate CONSTRAINT "waterings_tree_id_fkey";

ALTER TABLE "public"."waterings"
	ADD CONSTRAINT "waterings_user_id_fkey" FOREIGN KEY (user_id) REFERENCES profiles (id) NOT valid;

ALTER TABLE "public"."waterings" validate CONSTRAINT "waterings_user_id_fkey";

SET check_function_bodies = OFF;

CREATE OR REPLACE FUNCTION public.handle_new_user ()
	RETURNS TRIGGER
	LANGUAGE plpgsql
	SECURITY DEFINER
	SET search_path TO 'public'
	AS $function$
BEGIN
	INSERT INTO public.profiles (id)
		VALUES (NEW.id);
	RETURN new;
END;
$function$;

CREATE POLICY "Enable read access for all users" ON public.trees AS PERMISSIVE
	FOR SELECT TO public
		USING (TRUE);

CREATE POLICY "Public adoptions are viewable by everyone." ON "public"."adoptions" AS permissive
	FOR SELECT TO public
		USING (TRUE);

CREATE POLICY "Users can delete own adoptions." ON "public"."adoptions" AS permissive
	FOR DELETE TO public
		USING ((auth.uid () = user_id));

CREATE POLICY "Users can insert their own adoptions." ON "public"."adoptions" AS permissive
	FOR INSERT TO public
		WITH CHECK ((auth.uid () = user_id));

CREATE POLICY "Users can update own adoptions." ON "public"."adoptions" AS permissive
	FOR UPDATE TO public
		USING ((auth.uid () = user_id));

CREATE POLICY "Public profiles are viewable by everyone." ON "public"."profiles" AS permissive
	FOR SELECT TO public
		USING (TRUE);

CREATE POLICY "Public trees are viewable by everyone." ON "public"."profiles" AS permissive
	FOR SELECT TO public
		USING (TRUE);

CREATE POLICY "Users can insert their own profile." ON "public"."profiles" AS permissive
	FOR INSERT TO public
		WITH CHECK ((auth.uid () = id));

CREATE POLICY "Users can update own profile." ON "public"."profiles" AS permissive
	FOR UPDATE TO public
		USING ((auth.uid () = id));

CREATE POLICY "Public waterings are viewable by everyone." ON "public"."waterings" AS permissive
	FOR SELECT TO public
		USING (TRUE);

CREATE POLICY "Users can delete own waterings." ON "public"."waterings" AS permissive
	FOR DELETE TO public
		USING ((auth.uid () = user_id));

CREATE POLICY "Users can insert their own waterings." ON "public"."waterings" AS permissive
	FOR INSERT TO public
		WITH CHECK ((auth.uid () = user_id));

CREATE POLICY "Users can update own waterings." ON "public"."waterings" AS permissive
	FOR UPDATE TO public
		USING ((auth.uid () = user_id));

CREATE MATERIALIZED VIEW "public"."trees_with_district" AS
SELECT
	trees.id AS tree_id,
	trees.type AS tree_type,
	trees.geom AS tree_geom,
	trees.height AS tree_height,
	trees.age AS tree_age,
	districts.name AS district_name,
	districts.id AS district_id
FROM (trees
	JOIN districts ON (st_contains (districts.geom, trees.geom)));

